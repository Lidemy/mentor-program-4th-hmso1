## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫
### 加密
加密需要密鑰去將原文轉換成密文，如果用同一條密鑰去解密就稱為對稱式加密，例如：凱薩加密是以 0-25 作為偏移量為原文加密，AES 的密鑰量可以高達 10^38 種為用戶提供安全的加密。

第二種加密方法是非對稱式加密，非對稱式加密是有 2 條密鑰分別用作加密和解密用的。非對稱式加密是為了防止第三方用戶拿取到密鑰去解密，因為如果我要將密文傳給對方時，在第一次溝通時我一定要附上密鑰對方才知道如何去解密，這個時候第三方就有機會從中偷取到密鑰並對我所發的密文解密。

因為非對稱式加密會有 2 條密鑰：公鑰和私鑰，對方只會給我加密用的公鑰，私鑰會來為密文解密用。因為私鑰不會傳送出去，第三方不能偷取到也解密不到原文。

### 雜湊
雜湊將原文放進一個雜湊函數從而得出一個固定長度的雜湊值，雜湊有以下的特性：
- 不能從雜湊值推算回原文是什麼
- 相同的原文經過雜湊函數得出同樣的結果
- 使用相同雜湊函數計算出來的雜湊值長度一定會是一樣
因為雜湊值的長度是固定，所以雜湊值會是一個有上限的值，可能會有 2 個不同的輸入得出同樣的雜湊值，也稱之為碰撞，一個好的雜湊函數會較少出現碰撞的機會。

因為雜湊是不可逆的，所以當資料被第三方偷取都難以去推算原文是什麼，為此彩虹表誕生。彩虹表是用作破解雜湊值，它會將常見的原文經雜湊後儲存到資料庫，再於密文作對比。為防止彩虹表的破解或者加大破解的難度，使用者會在雜湊前為原文加上自訂的字串，可以加在原文前後，也可以加在原文內，這個操作叫作加鹽。因為原文只有少少的不同，出來的雜湊值會不同，使彩虹表好難去破解加鹽後的雜湊值。

### 雜湊跟加密的差別

雜湊跟加密的差別是加密是雙向的可以由密文解密成原文，而雜湊是不可逆的，只可以靠暴力輸入不同的原文去和雜湊值核對是否一樣。加密是用於和對方交換資訊時，不想給第三方知道。雜湊更多是用於檢查檔案有沒有被竄改或是驗證使用者密碼。

### 為什麼密碼要雜湊過後才存入資料庫
資安的原因下，資料庫內的密碼都不應該以明密儲存。為了防止駭客偷取了資料庫的資料後就輕易拿到所有使用者的密碼，或者防止網站管理者因為故意或不小心的原因將資料外洩。

事實上，網頁是不需要知道使用者的密碼，因為相同的原文經過雜湊函數得出同樣的結果的特性，它只需要確保密碼雜湊值是一樣就代表使用者登入成功。這也是碰撞的機會不可以太大的原因。

## `include`、`require`、`include_once`、`require_once` 的差別
以上都是用於在 PHP 上中引入檔案。

`include` 和 `require` 的分別是 `include` 如果找不到要引入的檔案只會出 warning，並會繼續執行餘下的程式碼，而 `require` 找不到要引入的檔案會立即停止並出 error。

`xxxxx_once` 的意思是會防止引入的檔案重覆，重覆引入有機會多次定義同名的變數或函式使程式碼出 error。所以無論是用 `include` 或 `require` 都應該使用 `include_error` 和 `require_once`。

## 請說明 SQL Injection 的攻擊原理以及防範方法
### SQL Injection 攻擊原理
駭客會使用 SQL 語法去竄改原本 SQL 的邏輯從中取得資料庫的內容，例子：

```php
$sql = sprintf("SELECT * FROM users WHERE username='%s'", $username);
$result = $conn->query($sql);
```
如果駭客將 $username 寫成 `' OR 1=1 /*`，SQL 的語法就會變成
```sql
SELECT * FROM users WHERE username='' OR 1=1 /*
```
因為 1=1 會是 true，`users` 資料庫的所有 col 和 row 會全部 query 出來給駭客知道。

### 防範方法
使用 prepare statement 的方法防範 SQL Injection。 Prepare statement 將 SQL 語法分為 2 個部份：SQL 本體語法的和參數的傳入。因為使用者的輸入一定會以參數的部份去處理所以 SQL 語法的本體是不會受到影響。所有用到 SQL 的地方都要用到 prepare statement 以防範漏洞。

在 PHP 中的寫法
```php
// 問號是將要傳入參數的位置
$sql = "SELECT *FROM users WHERE username=?";

// 準備 SQL 本體部份
$stmt = $conn->prepare($sql);

//傳入參數，第一個 argument 用來表達參數的類型
$stmt->bind_param("s", $username);

//執行 SQL query
$result = $stmt->execute();
```

##  請說明 XSS 的攻擊原理以及防範方法
### XSS 的攻擊原理
惡意地植入 html 語法到網頁上，例如有個留言板給使用者輸入留言，使用者輸入：

```html
<script> alert("hacked") </script>
```

這段文字傳入資料庫是沒有問題的，但當我們直攘拿這條資料到前端網頁時會變成
```html
<div>
  <!-- 放留言的地方 -->
  <script> alert("hacked") </script>
</div>
```
出現在畫面的不會是這條資料而是一個 alert 訊息。大多數的 XSS 攻擊會用於偷取瀏覧器的 cookie 和 惡意轉跳到其他網頁。偷取瀏覧器的 cookie 使駭客不需要知道使用者的賬碼和密碼下都可以模仿使用者的登入狀態。而惡意轉跳就可以將使用者騙到其他網頁或者用一個仿網頁去偷取使用者個人資料。

### 防範方法
XXS 會發生的原因是網頁將使用者的輸入以 html 語法去解讀，只要網頁將所有輸入以文字去解讀就不會有問題。

在 PHP 中我們有內建的 htmlspecialchars 去幫忙資料轉換到純文字。
```html
<div>
  <!-- 放留言的地方 -->
  htmlspecialchars(<script> alert("hacked") </script>)
</div>
```
htmlspecialchars 應該在拿出資料後執行而不是在將輸入處理後才儲入資料庫。因為可能有其他平台去存取該資料庫，處理過後的資料在其他平台拿出來會同原文不同。


## 請說明 CSRF 的攻擊原理以及防範方法
### CSRF 的攻擊原理
惡意網站會在使用者不知情下向其他網頁發出 request 並作出惡意操作。因為瀏覽器不會判斷這是一個跨站請求，它會附上該網頁的 cookie，使網頁以為是使用者操作。 

### 防範方法
- 使用者可以每次都登出網頁，使登入狀態不會記錄在瀏覽器中
- 要求使用者輸入驗證碼，因為惡意網站不知道驗證碼，所以完成不到之後的操作。
- 使用 POST 來傳遞資料，在表單中加上 CSRF token 去認證 request 是由網頁 domain 送出，而不是跨站請求。

CSRF token 都是由 server 隨機造出，但儲存的地方可以分為 2 種：session 或 cookie。原理都是一樣，將表單內的 CSRF token 和 session 或 cookie 的 CSRF token 核對，一樣的就代表是由使用者發出。 因為惡意網站不知道你的 token 所以不能在表單內仿做。

- 在瀏覧器的 set-cookie 中設定 `SameSite` ，`SameSite` 都有 2 種模式：`Lax` 和 `Strict`。後者，會對所跨站請求都不附上 cookie。前者只會在 POST, PUT, DELETE 的方法時不附上 cookie。`Lax` 保留了 cookie 帶來的方便性，因為 <a>, <link>, <form method="GET"> 都會附上 cookie，但就要小心 CSRF 對 GET 的攻擊。